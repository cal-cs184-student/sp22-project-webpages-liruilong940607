<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<head>
    <style>
        body {
            padding: 100px;
            width: 1000px;
            margin: auto;
            text-align: left;
            font-weight: 300;
            font-family: 'Open Sans', sans-serif;
            color: #121212;
        }
        
        h1,
        h2,
        h3,
        h4 {
            font-family: 'Source Sans Pro', sans-serif;
        }

		img {
			border: 1px solid #555;
		}
    </style>
    <title>CS 184 Rasterizer</title>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <link href="https://fonts.googleapis.com/css?family=Open+Sans|Source+Sans+Pro" rel="stylesheet">
</head>


<body>

    <h1 align="middle">CS 184/284: Computer Graphics and Imaging, Spring 2022</h1>
    <h1 align="middle">Project 1: Rasterizer</h1>
    <h2 align="middle">Ruilong Li</h2>
    <h2 align="middle">CS284 - 3037377380</h2>

    <br><br>

    <div>

        <h2 align="middle">Overview</h2>

        <!-- Give a high-level overview of what you implemented in this project. 
        Think about what you've built as a whole. Share your thoughts on what 
        interesting things you've learned from completing the project. -->
        <p>
            In this first assignment, I get familiar with how the vector format data 
            (e.g. SVG images) is being drawn to the screen. It is superisingly 
            interesting that the underlying representation of SVG images are actually
            a bunch of triangles with colors or texture maps, similar to the 3D meshes. 
            This assignment helps me to reveal the mystery on why some SVG images can 
            be "infinite resolution" -- it's just rasterization of the colored triangles!
        </p>

        <p>
            Besides, through the implementation of sub-pixel sampling, multi-level mipmaps
            texture mapping etc, I get the chance to closely feel the visual differences
            on the screen, with different underlying technologies. Really devil is in the
            detail! A slight change could lead to a huge improvment towards visual pleasing. 
            And like wise, a tiny bug could also cause unimaginable "art" results!
        </p>

        <h2 align="middle">Section I: Rasterization</h2>
		
		<!-- Task 1 -->
        <h3 align="middle">Part 1: Rasterizing single-color triangles</h3>
		
		<p><b>I. Walk through how you rasterize triangles in your own words.</b></p>
		<blockquote>
			<p>
			For the SVG images, the rasterization process is to get the color 
			of all pixels covered by a specific triangle. We can process each
			triangle seperately because there are no occlusions across triangles
			for SVG images, unlike 3D meshes. 
			</p>
			<p>
			Implementation wise, we need to 
			conduct the three-line test for each pixel to decide whether it is 
			within a specific triangle. If it is inside, then the pixel color can
			be accquire from the triangle, otherwise, we can safely skip this pixel,
			and let other traingles to decide its color.
			</p>
		</blockquote>
		
		<p><b>
			II. Explain how your algorithm is no worse than one that checks 
			each sample within the bounding box of the triangle.
		</b></p>
		<blockquote>
			<p>In my implementation, I just forloop all the samples inside the bounding box.</p>
		</blockquote>
			
		<p><b>
			III. Show a <em>png</em> screenshot of <em>basic/test4.svg</em> with the 
			default viewing parameters and with the pixel inspector centered on 
			an interesting part of the scene.
		</b></p>

		<div align="middle">
			<img src="images/task1.3.png" align="middle" width="400px" />
			<figcaption align="middle">
				The rasterization of <em>basic/test4.svg</em>.
			</figcaption>
        </div>
		
		<!-- Task 2 -->
        <h3 align="middle">Part 2: Antialiasing triangles</h3>

		<p><b>I. Walk through your supersampling algorithm and data structures. 
			Why is supersampling useful? What modifications did you make to the 
			rasterization pipeline in the process? Explain how you used supersampling 
			to antialias your triangles.
		</b></p>
		<blockquote><p>
			The idea behind the supersampling method for antialiasing, is to smooth the
			edge of the traingles, by locally averaging color on the edge. A 
			straight-forward way to do this is to split each sample into multiple sub-samples
			around it and calculate the color by averaging all those sub-samples. Implementation
			wise, we have to host a buffer that has a larger resolution than the actual image,
			for those sub-samples. Then after the rasterization, a simple averaging on on the 
			sub-samples give you the final color for all the samples. 
		</p></blockquote>

		<p><b>II. Show png screenshots of basic/test4.svg with the default viewing 
			parameters and sample rates 1, 4, and 16 to compare them side-by-side. 
			Position the pixel inspector over an area that showcases the effect 
			dramatically; for example, a very skinny triangle corner. Explain 
			why these results are observed.
		</b></p>

		<div align="middle">
			<img src="images/task2.2.1.png" align="middle" width="400px" />
			<figcaption align="middle">Supersample rate 1 per pixel.</figcaption>
        </div>
		<div align="middle">
            <table width="80%">
                <tr>
                    <td>
                        <img src="images/task2.2.2.png" align="middle" width="400px" />
                        <figcaption align="middle">Supersample rate 4 per pixel.</figcaption>
                    </td>
                    <td>
                        <img src="images/task2.2.3.png" align="middle" width="400px" />
                        <figcaption align="middle">Supersample rate 9 per pixel.</figcaption>
                    </td>
                </tr>
            </table>
        </div>

		<!-- Task 3 -->
        <h3 align="middle">Part 3: Transforms</h3>

		<p><b>Create an updated version of svg/transforms/robot.svg with cubeman 
			doing something more interesting, like waving or running. Feel free to 
			change his colors or proportions to suit your creativity. Save your svg 
			file as my_robot.svg in your docs/ directory and show a png screenshot 
			of your rendered drawing in your write-up. Explain what you were trying 
			to do with cubeman in words.
		</b></p>

		<div align="middle">
            <table width="70%">
                <tr>
                    <td>
                        <img src="images/task3.1.1.png" align="middle" width="400px" />
                        <figcaption align="middle">Cubeman dancing bullet!</figcaption>
                    </td>
                    <td>
                        <img src="images/task3.1.2.png" align="middle" width="300px" />
                        <figcaption align="middle">
							Reference image. 
							Source: <a href="https://www.dancesupplies.com/Ballet-Rosa-Amelie-Leotard.html?gclid=Cj0KCQiAu62QBhC7ARIsALXijXTsZOCV5ZakKA4OBaYHS3CfELzuPNQCcQP2ZMf77gmatOEKrXIlUCsaAgtnEALw_wcB">link</a>
						</figcaption>
                    </td>
                </tr>
            </table>
        </div>



        <h2 align="middle">Section II: Sampling</h2>

		<!-- Task 4 -->
        <h3 align="middle">Part 4: Barycentric coordinates</h3>

		<p><b>Explain barycentric coordinates in your own words and use an image 
			to aid you in your explanation. One idea is to use a svg file that plots 
			a single triangle with one red, one green, and one blue vertex, which 
			should produce a smoothly blended color triangle.
		</b></p>
		<blockquote><p>
			The barycentric coordinates of a point p represents how close this p to each
			vertex of the triangle. The more close, the more it would be affected by that 
			perticular vertex. So the attributes of the point p can be generally interpolated
			with barycentric coordinates on the attributes of the vertices. Implementation wise,
			the barycentric coordinates equal to the area of the three sub-triangles divided by the
			point p.
		</p></blockquote>
		<div align="middle">
			<img src="images/task4.1.png" align="middle" width="400px" />
			<figcaption align="middle">Barycentric interpolation from red, green, blue.</figcaption>
        </div>


		<p><b>Show a png screenshot of svg/basic/test7.svg with default viewing 
			parameters and sample rate 1. If you make any additional images with 
			color gradients, include them.
		</b></p>
		<div align="middle">
			<img src="images/task4.2.png" align="middle" width="400px" />
			<figcaption align="middle">Screenshot of svg/basic/test7.svg.</figcaption>
        </div>

		<!-- Task 5 -->
        <h3 align="middle">Part 5: "Pixel sampling" for texture mapping</h3>

		<p><b>Explain pixel sampling in your own words and describe how you 
			implemented it to perform texture mapping. Briefly discuss the two 
			different pixel sampling methods, nearest and bilinear.
		</b></p>

		<p><b>Check out the svg files in the svg/texmap/ directory. Use the pixel 
			inspector to find a good example of where bilinear sampling clearly 
			defeats nearest sampling. Show and compare four png screenshots using 
			nearest sampling at 1 sample per pixel, nearest sampling at 16 samples 
			per pixel, bilinear sampling at 1 sample per pixel, and bilinear 
			sampling at 16 samples per pixel.
		</b></p>

		<p><b>Comment on the relative differences. Discuss when there will be a large 
			difference between the two methods and why.
		</b></p>


        <h3 align="middle">Part 6: "Level sampling" with mipmaps for texture mapping</h3>



        <h2 align="middle">Section III: Art Competition</h2>
        <p>If you are not participating in the optional art competition, don't worry about this section!</p>

        <h3 align="middle">Part 7: Draw something interesting!</h3>

</body>

</html>